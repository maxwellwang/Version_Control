Test 1
$ ./WTF configure frost.cs.rutgers.edu 8080
We test configure first since it is the foundational command to allow all other commands that connect to the server to be able to
connect to the server using the .configure file's IP address/hostname and port number. Thus it makes sense to test this right away.
Test 2
$ ./WTF create myproject
Next, we test creating the project directory in both the client and server sides. Since all the other commands involve projects,
it makes sense to test this second. Connecting to the server to create a directory on that side shows that the configure information
is correctly working, and then replicating that directory on the client side too makes sure we can make the directories on both sides.
Finally, the creation of the manifests initialized with version 0 prepares for the other commands.
Test 3
$ ./WTF destroy myproject; rm -rf myproject; ./WTF create myproject
Finally, we test destroy. This destroys the project on the serverside. Now we have verified that we can create a project, perform
multiple operations on it, and finally destroy the project once all is done.
Test 4
$ echo "text" > myproject/myfile; ./WTF add myproject myfile
Next, we test adding a file within the project directory to its manifest file. This prepares the added file change to be committed
and then pushed to the server. Once we have the file path, version, and hash in the client side project manifest, it is ready to be
committed and pushed.
Test 5
$ ./WTF commit myproject
Next, we test committing the add file change that we just added to the manifest. This test checks to see if the correct .Commit file
is created, one that says to add the new myfile to the serverside project. Once this commit file is verified to be correct, the push
command has everything it needs to execute that change on the serverside.
Test 6
$ ./WTF push myproject
Next, we test pushing the committed change. This change should result in myfile being created on the serverside project. Also, the
server project's manifest should show the file as well. Finally, the client should copy this information: since it just pushed its
changes to the directory, it makes sense that it should be up to date, having the same contents as the server project.
Test 7
$ ./WTF update myproject
Next, we test updating the clientside project. Since we just pushed, the results should be that the project is up to date and no
upgrading is necessary.
Test 8
$ ./WTF upgrade myproject
Next, we test upgrading the clientside project. The update command would have just responded that the project is up to date, so the
upgrade here should just do nothing.
Test 9
$ ./WTF currentversion myproject
Next, we test currentversion. This is a simple command that just prints out the files and their versions in the server project
directory.
Test 10
$ ./WTF history myproject
Next, we test history. This is also a simple command since we have a .History file keeping track of all the commits pushed to the
server.
Test 11
$ rm -rf myproject; ./WTF rollback myproject 0
Next, we test rollback. But first we remove myproject from clientside to prepare my checkout test. Rollback should access the old
project version that we store in the server project.
Test 12
$ ./WTF checkout myproject
Next, we test checkout. This checks out the server myproject back to the client, except now it is the version 0 edition of the
project where myfile should not be in the project.
Thread Synchronization Test
Additionally, we made requests of the server from multiple clients trying to edit or use the same project. We put sleep() lines
within the server code for the first command and then attempted to execute the second command from another client. Each time, the
second command was blocked due to the mutex lock of the project directory by the first client's command. Therefore, we knew that
the threads were properly synchronized so that once one client/thread was accessing a project, other threads were blocked from
interfering until the first client/thread had completed.
